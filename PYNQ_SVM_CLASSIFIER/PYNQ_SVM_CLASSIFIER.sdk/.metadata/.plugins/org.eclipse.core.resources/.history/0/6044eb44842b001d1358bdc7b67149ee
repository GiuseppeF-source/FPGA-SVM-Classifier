#include "stdio.h"
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xil_cache.h"
#include "xgpio.h"
#include "sleep.h"
#include "xbram.h"
#include "xaxidma.h"

/********* GPIO *********/
XGpio Gpio; 					/* The Instance of the GPIO Driver */
/* The following constant is used to determine which channel of the GPIO is used. */
#define START 1
#define CLASSIFICATION 2

/********* BRAM CONTROLLER *********/
XBram_Config *ConfigPtr_BRAM_PCV;  			/* Pointer to the configuration of BRAM CONTROLLER */
XBram_Config *ConfigPtr_BRAM_Kernel_Scale;
XBram_Config *ConfigPtr_BRAM_Bias;
XBram BRAM_PCV;							   /* The Instance of the BRAM Driver */
XBram BRAM_Kernel_Scale;
XBram BRAM_Bias;

/********* DMA *********/
XAxiDma AxiDma;

/********* DDR Allocation *********/
#define n_SVM  15
u32 Bias[n_SVM];          // dei 32 bit solo i   7 meno significativi  sono effettivi
u32 Kernel_Scale[n_SVM];  // dei 32 bit solo i  12 meno significativi  sono effettivi
u32 PCV[34*n_SVM];        // dei 32 bit solo i  12 meno significativi  sono effettivi
u32 Attribute_Test[9*36]; // ogni u32 contiene 4 Attributi da 8bit, per un totale di 36 query da classificare ( da 34 attributi)

int main()
{
    init_platform();
    Xil_DCacheDisable();
    xil_printf("Avvio Programma\n\r");

	/* Initialize the GPIO driver */
    int Status_Gpio;

    Status_Gpio = XGpio_Initialize(&Gpio, XPAR_GPIO_0_DEVICE_ID);

	if (Status_Gpio != XST_SUCCESS) {
		xil_printf("Gpio Initialization Failed\r\n");
		return XST_FAILURE;
	}

	/* Set the direction for all signals  */
	XGpio_SetDataDirection(&Gpio, START         , 0); // channel start -> output
	XGpio_SetDataDirection(&Gpio, CLASSIFICATION, 0); // channel classification -> output
	xil_printf("GPIO per controllo FSM  settati in output \r\n");

	/* Send combination 00 -> STATE IDLE to PL */
	XGpio_DiscreteWrite(&Gpio, START         , 0);
	XGpio_DiscreteWrite(&Gpio, CLASSIFICATION, 0);
	xil_printf("START = 0 , CLASSIFICATION = 0 \r\n");

	sleep(1); // wait for 1sec

	/* Send combination 10 ->STATE SETUP to PL */
	XGpio_DiscreteWrite(&Gpio, START         , 1);
	XGpio_DiscreteWrite(&Gpio, CLASSIFICATION, 0);
	xil_printf("START = 1 , CLASSIFICATION = 0 \r\n");

	sleep(1); // wait for 1sec

	/* Initialize the BRAM CONTROLLER driver */
	int Status_BRAMC;

	/* Configuration BRAM Pre-Computed Vector */
	ConfigPtr_BRAM_PCV = XBram_LookupConfig( XPAR_AXI_BRAM_CTRL_0_DEVICE_ID );
	if (ConfigPtr_BRAM_PCV == (XBram_Config *) NULL) {
		return XST_FAILURE;
	}
	Status_BRAMC = XBram_CfgInitialize(&BRAM_PCV, ConfigPtr_BRAM_PCV, ConfigPtr_BRAM_PCV->CtrlBaseAddress);
	if (Status_BRAMC != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("Controller BRAM_PCV -> Inizializzato \r\n");

	/* Configuration BRAM Kernel Scale */
	ConfigPtr_BRAM_Kernel_Scale = XBram_LookupConfig( XPAR_AXI_BRAM_CTRL_1_DEVICE_ID );
	if (ConfigPtr_BRAM_Kernel_Scale == (XBram_Config *) NULL) {
		return XST_FAILURE;
	}
	Status_BRAMC = XBram_CfgInitialize(&BRAM_Kernel_Scale, ConfigPtr_BRAM_Kernel_Scale, ConfigPtr_BRAM_Kernel_Scale->CtrlBaseAddress);
	if (Status_BRAMC != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("Controller BRAM_Kernel_Scale -> Inizializzato \r\n");

	/* Configuration BRAM Bias */
	ConfigPtr_BRAM_Bias = XBram_LookupConfig( XPAR_AXI_BRAM_CTRL_2_DEVICE_ID );
	if (ConfigPtr_BRAM_Bias == (XBram_Config *) NULL) {
		return XST_FAILURE;
	}
	Status_BRAMC = XBram_CfgInitialize(&BRAM_Bias, ConfigPtr_BRAM_Bias, ConfigPtr_BRAM_Bias->CtrlBaseAddress);
	if (Status_BRAMC != XST_SUCCESS) {
		return XST_FAILURE;
	}
	xil_printf("Controller BRAM_Bias -> Inizializzato \r\n");

	/* Caricamento BRAM */



	////////////// SCRITTURA IN DDR DEI COEFFICIENTI /////////////////
	xil_printf("Indirizzo memoria Bias: %0x\n\r",Bias);
	xil_printf("Indirizzo memoria Kernel_Scale: %0x\n\r",Kernel_Scale);

	char c;
	xil_printf("Per continuare inserire un qualsiasi carattere \n\r");
	scanf("%c",&c);

	u32 RdatoDDR;
	for (u32 i=0; i<15; i=i+1) {
		//RdatoDDR = Xil_In32(Bias + (i*4));
		//xil_printf("Coeff = %x\n", RdatoDDR);
		xil_printf("%d\n\r",Bias[i]);
	}
	for (u32 i=0; i<15; i=i+1) {
		//RdatoDDR = Xil_In32(Bias + (i*4));
		//xil_printf("Coeff = %x\n", RdatoDDR);
		xil_printf("%d\n\r",Kernel_Scale[i]);
	}

    cleanup_platform();
    return 0;
}
